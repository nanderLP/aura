import { useEffect, useRef } from "react";
import create from "zustand";
import { combine } from "zustand/middleware";

/**
 * the current mode of the client
 */
type Mode = "connect" | "host";

interface Client {
  /**
   * The client's unique id, generated by the server with nanoid
   */
  id: string;
  mode: Mode;
  /**
   * object for storing important data for establishing a webrtc connection between two clients
   */
  rtc: {
    // TODO: rtc stuff types
  };
}

// the init event sends a me object with information about yourself
// currently it only sends the id and mode, and because the mode is saved somewhere else, we only save the id
interface Me {
  id?: string;
}

interface State {
  /**
   * the clients in the room
   */
  clients: Client[];
  /**
   * information about yourself in the room-context
   */
  me: Me;
  mode: Mode;
  /**
   * 4 digit code, used to identify the room and may be used for cross-wifi connection
   */
  code?: string;
  /**
   * specifies if you are connected to a room
   */
  connected: boolean;
}

const defaultMode: Mode = "connect";

const initialState: State = {
  clients: [],
  me: {},
  code: undefined,
  mode: defaultMode,
  connected: false,
};

const useStore = create(combine(initialState, (set, get) => {
  const ws = new WebSocket("ws://localhost:8000?mode=" + defaultMode);

  ws.onopen = (e) => {
    console.log("CONNECTED", e);
    set({ connected: true });
  };

  ws.onclose = (e) => {
    console.log("DISCONNECTED", e);
    set({ connected: false });
  };

  ws.onerror = (e) => {
    console.log("ERROR", e);
  };

  ws.onmessage = (e) => {
    const { payload, ...data } = JSON.parse(e.data);

    console.log("MESSAGE", data, payload);

    try {
      switch (data.type) {
        case "message": {
          // use message
          break;
        }
        case "mode": {
          // this is probably obsolete but i'll keep using it for debugging purposes
          const clientFound = get().clients.find((c) => c.id === payload.id);
          if (!clientFound) {
            throw new Error("client not found, that should not happen");
          }

          const modifiedClients = get().clients.map((c) => {
            if (c.id === payload.id) {
              c.mode = payload.mode;
            }
            return c;
          });

          // replace client in array
          // dunno if i can make this more efficient
          set((state) => ({
            ...state,
            clients: modifiedClients,
          }));
          break;
        }
        case "join": {
          const client = payload as Client;
          set((state) => ({
            ...state,
            clients: [...state.clients, client],
          }));
          break;
        }
        case "leave": {
          const leaverId = payload.id;
          set((state) => ({
            ...state,
            clients: state.clients.filter((c) => c.id !== leaverId),
          }));
          break;
        }
        case "init": {
          // save all the stuff we get (clients)
          const { clients, me, code } = payload;
          set((state) => ({
            ...state,
            clients,
            me,
            code,
          }));
          break;
        }
      }
    } catch (e) {
      console.log("ONMESSAGE ERROR", e);
      console.log("CLIENTS", get().clients);
    }
  };

  return {
    setMode(mode: Mode) {
      console.log("SETMODE", mode);
      // broadcast mode change
      ws.send(JSON.stringify({ type: "mode", payload: { mode } }));
      set((state) => ({
        ...state,
        mode,
      }));
    },
  };
}));

export default useStore;
